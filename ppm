#!/bin/bash

readonly _dirname=`dirname $0`
source $_dirname/binz/colorsh &>/dev/null  

read -d "" rcTemplate << EOS
# Project name
  name=

# Project repositories
  primary=
  secondary=
  tertiary=

# Project submodules
EOS

# Associative arrays are iterated out-of-order.  Hence - two arrays.
readonly -a rcFields=(
  "name"
  "primary"
  "secondary"
  "tertiary"
)
readonly -a fieldDescriptions=(
  "Project Name"
  "Primary"
  "Secondary"
  "Tertiary"
)

function get()
{
  echo `grep -oP "(?<=$1=).*$" $2`  
}

function clean()
{
  git remote remove origin &>/dev/null || true
}

function install()
{
  installSubmodules
  installRemotes  
}

function installSubmodules()
{
  printf "${green}Installing any submodules -\n"
  submodules=$(grep -A 10 "^# Project submodules\s*$" .ppmrc | 
    grep -P "^[^#]" | 
    sed "s/\s*//")

  add $submodules
}

function installRemotes()
{
  clean
  printf ${lightGreen}
  if git remote add origin $(get primary .ppmrc); then
    printf "\n${lightGreen}Set fetch URL `get primary .ppmrc`\n${reset}"
  fi
  for remote in primary secondary tertiary; do
    if git remote set-url --add --push origin $(get $remote .ppmrc); then
      printf "${lightGreen}Set push URL `get $remote .ppmrc`\n" 
    fi
  done
  printf "\n"
}

function path()
{
  pathAppend="export PATH+=:`pwd`"
  if grep "^${pathAppend}$" ~/.bashrc &>/dev/null; then
    printf "${yellow}`pwd` already added to PATH permanently in ~/.bashrc"
  elif echo $pathAppend >> ~/.bashrc; then
    printf "${green}`pwd` added to PATH permanently in ~/.bashrc"
  else
    printf "${red}There was an error adding `pwd` to PATH in ~/.bashrc"
  fi
  printf "${reset}\n"
}

# Add a new dependency (git submodule)
function add()
{
  for i in $@; do
    git submodule add $i
    git submodule init
    git submodule update

    (cd $(echo $i | grep -oP "\w*(?=\.git)") && install)
    if ! grep $i .ppmrc &>/dev/null; then printf "  $i\n" >> .ppmrc; fi;
  done
}

# Initialize a directory as a new git project
function init()
{
  printf "**********************************\n"
  printf "***  ${lightBlue}Phreedom Package Manager${reset}  *** ...by papiro\n"
  printf "**** ${blue}- \"Reinvent the wheel.\"${reset} *****\n\n"

  if [ -e .ppmrc ]; then
    printf "${yellow}Already initialized .ppmrc\n\n"
    exit 1
  fi

  if [[ $1 == "-d" ]]; then
    if [[ -e $_dirname/ppm.conf ]]; then
      for i in name primary secondary tertiary; do
        case $i in
          name)
            printf "${reset}${fieldDescriptions[name]}: ${lightYellow}"
            read name
            val=$name
            ;;
          *)
            val=`get $i $_dirname/ppm.conf`${name}.git
            ;;
        esac
        rcTemplate=${rcTemplate//$i=/$i=$val}
      done
    else
      printf "${red}No ppm.conf found in $_dirname/ppm directory${reset}"
      exit 1
    fi
  else
    for i in ${!rcFields[@]}; do
      field=${rcFields[$i]}
      while true; do
        printf "${reset}${fieldDescriptions[$i]}: ${lightYellow}"
        read ${field}
        if [[ -n ${!field} ]]; then
          rcTemplate=${rcTemplate//${field}=/${field}=${!field}}
          break
        fi
      done
    done
  fi

  # reset color
  printf "${reset}"
  ###

  printf "${rcTemplate}\n" > .ppmrc && printf "${lightGreen}.ppmrc created\n\n"
  git init
  installRemotes
}


function link()
{
  export PATH+=$(pwd)/bin
  exec /bin/bash
}

if [[ -z $1 ]]; then
  printf "Commands: \n"
  printf "${lightGreen}1. init\n"
  printf "${lightGreen}2. install\n"
  printf "${lightGreen}3. add\n"
fi

function -h()
{
  cat <<EOT
Usage: ppm [command] [option(s)]

  -h      display usage instructions
  -d      use default template in ppm.conf (only useful with the 'init' command)

${BGblue}${lightYellow}
   Primary, Secondary, and Tertiary are the Git repo URL's you will use to version-control/backup your project.${fillLine}
${fillLine}
   git@<domain:username><project-name>.git <-- Make sure to enter the full identifier, and that the repos already exist.  PPM will not create the repos for you.${fillLine}
${fillLine} 
   To create a local repo: ${bold}git init --bare /var/backups/<project-name>.git${fillLine}${reset}
EOT
  printf "${reset}"
}

`${!1}` $@
