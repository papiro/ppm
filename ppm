#!/bin/bash

source $(dirname $0)/binz/colorsh &>/dev/null  

read -d "" rcTemplate << EOS
# Project name
  name=

# Project repositories
  primary=
  secondary=
  tertiary=

# Project submodules
EOS

# Associative arrays are iterated out-of-order.  Hence - two arrays.
readonly -a rcFields=(
  "name"
  "primary"
  "secondary"
  "tertiary"
)
readonly -a fieldDescriptions=(
  "Project Name"
  "Primary"
  "Secondary"
  "Tertiary"
)

function get()
{
  echo `grep -oP "(?<=$1=).*$" .ppmrc`  
}

function clean()
{
  git remote remove origin &>/dev/null || true
}

function install()
{
  clean
  printf ${lightGreen}
  if git remote add origin $(get primary); then
    printf "\n${lightGreen}Set fetch URL `get primary`\n${reset}"
  fi
  for remote in primary secondary tertiary; do
    if git remote set-url --add --push origin $(get $remote); then
      printf "${lightGreen}Set push URL `get $remote`\n" 
    fi
  done
  printf "${green}Also installing any submodules -\n"
  submodules=$(grep -A 10 "^# Project submodules\s*$" .ppmrc | 
    grep -P "^[^#]" | 
    sed "s/\s*//")

  add $submodules
     
  printf "\n"
}

function path()
{
  pathAppend="export PATH+=:`pwd`"
  if grep "^${pathAppend}$" ~/.bashrc; then
    printf "${yellow}`pwd` already added to PATH permanently in ~/.bashrc"
  elif echo "" >> ~/.bashrc; then
    printf "${green}`pwd` added to PATH permanently in ~/.bashrc"
  else
    printf "${red}There was an error adding `pwd` to PATH in ~/.bashrc"
  fi
  printf ${reset}
}

# Add a new dependency (git submodule)
function add()
{
  for i in $@; do
    git submodule add $i
    git submodule init
    git submodule update

    (cd $(echo $i | grep -oP "\w*(?=\.git)") && install)
    if ! grep $i .ppmrc &>/dev/null; then printf "  $i\n" >> .ppmrc; fi;
  done
}

# Initialize a directory as a new git project
function init()
{
  printf "**********************************\n"
  printf "***  ${lightBlue}Phreedom Package Manager${reset}  *** ...by papiro\n"
  printf "**********************************\n\n"

  if [ -e .ppmrc ]; then
    printf "${yellow}Already initialized .ppmrc\n\n"
    exit 1
  fi
  
  printf "${BGblue}${lightYellow}"

  cat <<EOT
    Instructions${fillLine}
   ==============${fillLine}
   Primary, Secondary, and Tertiary are the Git repo URL's you will use to version-control/backup your project.${fillLine}
${fillLine}
Use a local path (i.e. (~/backups) if you'd prefer to use a local repository.${fillLine}
${fillLine}
   Having 3 allows some replication in (preferrably remote) backups.${fillLine}
${fillLine}
   git@<domain:username><project-name>.git <-- Make sure to enter the full identifier, and that the repos already exist.  PPM will not create the repos for you.${fillLine}
${fillLine} 
   To create a local repo, ${dim}do ${bold}git init --bare ~/backups/<project-name>.git${reset}${fillLine}

EOT
  printf "${reset}"

  for i in ${!rcFields[@]}; do
    field=${rcFields[$i]}
    while true; do
      printf "${reset}${fieldDescriptions[$i]}: ${lightYellow}"
      read ${field}
      if [[ -n ${!field} ]]; then
        rcTemplate=${rcTemplate//${field}=/${field}=${!field}}
        break
      fi
    done
  done

  # reset color
  printf "${reset}"
  ###

  printf "${rcTemplate}\n" > .ppmrc && printf "${lightGreen}.ppmrc created\n\n"
  install
}

function link()
{
  export PATH+=$(pwd)/bin
  exec /bin/bash
}

if [[ -z $1 ]]; then
  printf "Commands: \n"
  printf "${lightGreen}1. init\n"
  printf "${lightGreen}2. install\n"
  printf "${lightGreen}3. add\n"
fi

`${!1}` $@
