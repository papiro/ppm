#!/bin/bash

source $(dirname $0)/binz/colorsh &>/dev/null  

local_repo="~/Desktop/bomb_shelt/" #.ppm/repos/"

read -d "" rcTemplate << EOS
# Project name
  name=

# Project repositories
  primary=
  secondary=
  tertiary=

# Project submodules
EOS

# Associative arrays are iterated out-of-order.  Hence - two arrays.
readonly -a rcFields=(
  "name"
  "primary"
  "secondary"
  "tertiary"
)
readonly -a fieldDescriptions=(
  "Project Name"
  "Primary"
  "Secondary"
  "Tertiary"
)

function get()
{
  echo `grep -oP "(?<=$1=).*$" .ppmrc`  
}

function install()
{
  if [ ! -e .ppmrc ]; then 
    printf "${red}No .ppmrc\n"
    exit 1
  fi

  printf ${blue}
  if git init && \
    git remote add origin $(get primary); then
    printf "\n${blue}Set fetch URL `get primary`\n"
  fi
  restore
  printf "\n"
}

function restore()
{
  for remote in primary secondary tertiary; do
    if git remote set-url --add --push origin $(get $remote); then
      printf "${blue}Set push URL `get $remote`\n" 
    fi
  done
}

function path()
{
  if echo "export PATH+=:`pwd`" >> ~/.bashrc; then
    printf "${blue}`pwd` added to PATH permanently in ~/.bashrc"
  else
    printf "${red}There was an error adding `pwd` to PATH in ~/.bashrc"
  fi
  printf ${reset}
}

# Add a new dependency (git submodule)
function add()
{
  git submodule add $1
  git submodule init
  git submodule update

  echo "\n  $1" >> .ppmrc
  $(cd $(echo $1 | grep -oP "\w*(?=\.git)") && restore)
}

# Initialize a directory as a new git project
function init()
{
  printf "**********************************\n"
  printf "***  ${lightBlue}Phreedom Package Manager${reset}  *** ...by papiro\n"
  printf "**********************************\n\n"

  if [ -e .ppmrc ]; then
    printf "${yellow}Already initialized .ppmrc\n\n"
    exit 1
  fi
  
  printf "${BGblue}${lightYellow}"

  cat <<EOT
    Instructions${fillLine}
   ==============${fillLine}
   Primary, Secondary, and Tertiary are the Git repo URL's you will use to version-control/backup your project.${fillLine}
${fillLine}
Use a local path (i.e. ${local_repo}) if you'd prefer to use a local repository.${fillLine}
${fillLine}
   Having 3 allows some replication in (preferrably remote) backups.${fillLine}
${fillLine}
   git@<domain:username><project-name>.git <-- Make sure to enter the full identifier, and that the repos already exist.  PPM will not create the repos for you.${fillLine}
${fillLine} 
   To create a local repo, ${dim}do ${bold}git init --bare ${local_repo}${reset}${fillLine}

EOT
  printf "${reset}"

  for i in ${!rcFields[@]}; do
    field=${rcFields[$i]}
    while true; do
      printf "${reset}${fieldDescriptions[$i]}: ${lightYellow}"
      read ${field}
      if [[ -n ${!field} ]]; then
        rcTemplate=${rcTemplate//${field}=/${field}=${!field}}
        break
      fi
    done
  done

  # reset color
  printf "${reset}"
  ###

  echo "${rcTemplate}" > .ppmrc && printf "${lightGreen}.ppmrc created\n\n"
  install
}

function link()
{
  export PATH+=$(pwd)/bin
  exec /bin/bash
}

if [[ -z $1 ]]; then
  printf "Commands: \n"
  printf "${lightGreen}1. init\n"
  printf "${lightGreen}2. install\n"
  printf "${lightGreen}3. add\n"
fi

`${!1}` $@
